<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>component</title>
</head>
<body>
<div id="app">
    <my-component :list="lists">
        hi
        <h1>like</h1>
    </my-component>

    <!--如果子组件有 inline-template 特性，组件将把它的内容当作它的模板，而不是把它当作分发内容。这让模板更灵活。-->
    <!--疑惑：如果使用 内敛模板：又不能被动态template模板替换或者插入，有何意义，难道就只是多包了一层my-componet装13?-->
    <!--最佳实践是使用 template 选项在组件内定义模板或者在 .vue 文件中使用 template 元素-->
    <my-component inline-template>
       <div>
           <h1>good afternoon</h1>
           it uses the property of inline-template in the tag
       </div>
    </my-component>
</div>
<template id="J_LIST">
    <div>a custom component!<p v-for="con in list">{{con.name}}</p></div>
</template>
</body>
<script src="../lib/vue.js"></script>
<script>
    /*
    *
    * * 子组件可以通过this.$parent访问父组件
     * 父组件通过this.$children访问包含了所有子组件的数组
     * 根实例后代通过this.$root访问根实例（也即new Vue()）
     * 尽可能避免使用父链进行通信，应当尽可能使用props显示声明
     *
     *
     * * 触发事件：
     * $emit() 触发事件，子组件事件只能在子组件中被监听
     * $dispatch() 派发事件，事件沿着父链冒泡，子组件事件可以在父组件中监听
     * $broadcast() 广播事件，事件向下传递给所有后代，父组件事件可以在子组件中被监听
     * 监听事件：
     * $on() 监听事件
     * events选项监听事件
     * v-on指令监听事件
    * */
    var myComponent = {
        template: '#J_LIST',
        props: ["list"]
    }
    /* var myComponent = Vue.extend({
        template: '#J_LIST',
        props: ["list"]
    })*/

    Vue.component("my-component",myComponent);//用Vue.component全局注册了一个组件

    new Vue({
        el: "#app",
        data: {
            lists: [
                {
                    name: "fan",
                    age: 12,
                    sex: "female"
                },{
                    name: "hong",
                    age: 13,
                    sex: "male"
                }
            ]
        }
    })

</script>
</html>