<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Vue.nextTick(callback)</title>
</head>
<body>
<div id="app">{{msg}}</div>
<div id="example">
    <my-component></my-component>
</div>
<template id="J_msg">
    <div @click="updateMsg" title="点击可触发">{{msg}}</div>
</template>
</body>
<script src="../lib/vue2.1.3.js"></script>
<script>
    /**
     * 组件不会马上被重新渲染。当刷新队列时，这个组件会在下一次事件循环清空队列时更新。
     * 我们基本不用关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。一般来讲， Vue 鼓励开发者沿着数据驱动的思路，尽量避免直接接触 DOM，
     * 但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback)
     *
     * vm.$nextTick() 这个实例方法在组件内使用特别方便，因为它不需要全局 Vue ，它的回调 this 将自动绑定到当前的 Vue 实例上
     * */
var vm = new Vue({
    el: "#app",
    data: {
        count: 0,
        msg: "123"
    },
    methods: {
        changeIt: function() {
            this.count++;
        }
    }
})
    vm.msg = "new message";
    console.log(vm.$el.textContent);//"123"
    console.log(vm.$el.textContent === "new message");//false
    Vue.nextTick(function() {
        console.log(vm.$el.textContent === "new message");//true
    })


    var vm2 = new Vue({
        el: "#example",
        data: {
            msg: "123"
        },
        components: {
            "my-component": {
                template: "#J_msg",
                data: function() {
                    return {
                        msg: "not updated"
                    }
                },
                methods: {
                    updateMsg: function() {
                        this.msg = "updated";//not updated
                        console.log(this.$el.textContent);
                        this.$nextTick(function() {
                            console.log(this.$el.textContent === "updated");//true
                        })
                    }
                }
            }
        }
    })
</script>
</html>